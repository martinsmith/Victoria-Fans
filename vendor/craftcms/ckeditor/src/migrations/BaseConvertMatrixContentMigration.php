<?php

namespace craft\ckeditor\migrations;

use Craft;
use craft\ckeditor\Field;
use craft\db\Migration;
use craft\db\Query;
use craft\db\Table;
use craft\elements\Entry;
use craft\fieldlayoutelements\CustomField;
use craft\fields\PlainText;
use craft\helpers\ArrayHelper;
use yii\helpers\Markdown;

/**
 * Base convert matrix content migration class.
 *
 * This is extended by content migrations generated by the `ckeditor/convert/matrix` command.
 *
 * @since 4.2.0
 */
class BaseConvertMatrixContentMigration extends Migration
{
    public string $ckeFieldUid;
    public ?string $htmlEntryTypeUid;
    public ?string $htmlFieldUid;
    public string $markdownFlavor;
    public bool $preserveHtmlEntries;

    public function safeUp(): bool
    {
        $fieldsService = Craft::$app->getFields();
        $ckeField = $fieldsService->getFieldByUid($this->ckeFieldUid);

        if (!$ckeField) {
            echo "Invalid field UUID: $this->ckeFieldUid";
            return false;
        }

        if (!$ckeField instanceof Field) {
            echo "$ckeField->name is not a CKEditor field.";
            return false;
        }

        $htmlEntryType = null;
        $htmlField = null;

        $entriesService = Craft::$app->getEntries();
        if ($this->htmlEntryTypeUid) {
            $htmlEntryType = $entriesService->getEntryTypeByUid($this->htmlEntryTypeUid);
            if (!$htmlEntryType) {
                echo "Invalid entry type UUID: $this->htmlEntryTypeUid";
                return false;
            }

            if ($this->htmlFieldUid) {
                $htmlFieldLayoutElement = $htmlEntryType->getFieldLayout()->getElementByUid($this->htmlFieldUid);
                if (!$htmlFieldLayoutElement instanceof CustomField) {
                    echo "Invalid field layout element UUID: $this->htmlFieldUid";
                    return false;
                }
                $htmlField = $htmlFieldLayoutElement->getField();
            }
        }

        $elementsService = Craft::$app->getElements();

        // get all the owner element IDs that have nested entries for this field
        $ownerIds = (new Query())
            ->select('o.ownerId')
            ->from(['e' => Table::ENTRIES])
            ->innerJoin(['o' => Table::ELEMENTS_OWNERS], '[[o.elementId]] = [[e.id]]')
            ->where(['e.fieldId' => $ckeField->id])
            ->groupBy('ownerId')
            ->column();

        $nestedEntriesToDelete = [];
        $ownersToSave = [];

        foreach ($ownerIds as $ownerId) {
            // get all the nested entries for the owner/field
            /** @var Entry[] $allNestedEntries */
            $allNestedEntries = Entry::find()
                ->ownerId($ownerId)
                ->fieldId($ckeField->id)
                ->siteId('*')
                ->drafts(null)
                ->revisions(null)
                ->trashed(null)
                ->status(null)
                ->all();

            // group by site ID
            /** @var array<int,Entry[]> $groupedNestedEntries */
            $groupedNestedEntries = ArrayHelper::index($allNestedEntries, null, [
                fn(Entry $entry) => $entry->siteId,
            ]);

            foreach ($groupedNestedEntries as $nestedEntries) {
                // we're intentionally getting the site specific owner, from the nested entry
                $owner = $nestedEntries[0]->getOwner();

                echo sprintf('    > Updating %s %s ("%s") in %s … ', $owner::lowerDisplayName(),  $owner->id, $owner->getUiLabel(), $owner->getSite()->name);

                $value = '';
                // iterate through each nested entry,
                foreach ($nestedEntries as $entry) {
                    // only get the content if the nested entry is not soft-deleted
                    // or the owner is soft-deleted or the owner is a revision
                    if (!$entry->trashed || $owner->trashed || $owner->getIsRevision()) {
                        // if the nested entry is the one containing the top-level field,
                        // get its content and place it before the rest of that entry’s content
                        // possibly followed by the <craft-entry data-entry-id=\"<nested entry id>\"></craft-entry>
                        if ($entry->type->uid === $htmlEntryType?->uid) {
                            $textValue = $entry->getFieldValue($htmlField->handle);
                            if ($this->markdownFlavor !== 'none' && $htmlField instanceof PlainText) {
                                // Parse it as Markdown
                                $value .= Markdown::process($textValue, $this->markdownFlavor);
                            } else {
                                $value .= $textValue;
                            }

                            if ($this->preserveHtmlEntries) {
                                $value .= sprintf('<craft-entry data-entry-id="%s"></craft-entry>', $entry->id);
                            } else {
                                // don't delete straight away or some nested elements won't be available when
                                // e.g. processing the revisions of the owner
                                $nestedEntriesToDelete[] = $entry;
                            }
                        } else {
                            // for other nested entries add the <craft-entry data-entry-id=\"<nested entry id>\”></craft-entry>
                            $value .= sprintf('<craft-entry data-entry-id="%s"></craft-entry>', $entry->id);
                        }
                    }
                }

                $owner->setFieldValue($ckeField->handle, $value);
                // we can't save here or some nested elements won't be available when we process e.g. the revisions
                $ownersToSave[] = $owner;
                echo "✓\n";
            }
        }

        // now save all the amended owners
        if (!empty($ownersToSave)) {
            foreach ($ownersToSave as $owner) {
                $elementsService->saveElement($owner, false);
            }
        }

        // and delete all nested elements we no longer need
        if (!empty($nestedEntriesToDelete)) {
            foreach ($nestedEntriesToDelete as $nestedEntry) {
                $elementsService->deleteElement($nestedEntry);
            }
        }

        return true;
    }
}
